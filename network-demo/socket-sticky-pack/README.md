
# 一、Socket 粘包

## 什么是粘包？

粘包问题是指当发送两条消息时，比如发送了 ABC 和 DEF，但另一端接收到的却是 ABCD，像这种一次性读取了两条数据的情况就叫做粘包（正常情况应该是一条一条读取的）。

## 为什么会有粘包？

TCP 是面向连接的传输协议，TCP 传输的数据是以流的形式，而流数据是没有明确的开始结尾边界，所以 TCP 也没办法判断哪一段流属于一个消息。

#### 粘包的主要原因

* 发送方每次写入数据 小鱼 套接字（Socket）缓冲区大小；
* 接收方读取套接字（Socket）缓冲区数据不够及时。

#### 什么是缓冲区？

缓冲区又称为缓存，它是内存空间的一部分。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区。

缓冲区的优势以文件流的写入为例，如果我们不使用缓冲区，那么每次写操作 CPU 都会和低速存储设备也就是磁盘进行交互，那么整个写入文件的速度就会受制于低速的存储设备（磁盘）。但如果使用缓冲区的话，每次写操作会先将数据保存在高速缓冲区内存上，当缓冲区的数据到达某个阈值之后，再将文件一次性写入到磁盘上。因为内存的写入速度远远大于磁盘的写入速度，所以当有了缓冲区之后，文件的写入速度就被大大提升了。

# 粘包问题的3种解决方案

## 1、固定缓冲区大小
发送方和接收方规定固定大小的缓冲区，也就是发送和接收都使用固定大小的 byte[] 数组长度，当字符长度不够时使用空字符弥补。

### 优缺点分析

可以看到，虽然这种方式可以解决粘包的问题，但这种固定缓冲区大小的方式增加了不必要的数据传输，因为这种方式当发送的数据比较小时会使用空字符来弥补，所以这种方式就大大的增加了网络传输的负担，所以它也不是最佳的解决方案。


## 2、特殊字符结尾，按行读取

以特殊字符结尾就可以知道流的边界了，因此也可以用来解决粘包的问题。

这种解决方案的核心是，使用 BufferedReader 和 BufferedWriter，也就是带缓冲区的输入字符流和输出字符流，通过写入的时候加上 \n 来结尾，读取的时候使用 readLine 按行来读取数据，这样就知道流的边界了，从而解决了粘包的问题。

### 优缺点分析

使用分隔符的方式与上面的固定发送与接受端的缓冲区大小相比，解决了每次发送的package较大的问题，但是同时缺引入了一个新的问题，有可能在数据正文中包含了分隔符的内容，这时就会出现非预期的切割行为，导致没有正确获取预期的数据。

## 封装请求协议

实现思路是将请求的数据封装为两部分：数据头+数据正文，在数据头中存储数据正文的大小，当读取的数据小于数据头中的大小时，继续读取数据，直到读取的数据长度等于数据头中的长度时才停止。

### 优缺点分析

* 优点：综合了固定缓冲区大小和分隔符两种做法的优点，既不会导致每个数据包过大，也不会产生数据正文可能出现分隔符导致切分错误的情况，是解决`tcp`粘包的比较推荐的做法；
* 缺点：这种实现方式的编码成本较大也不够优雅。